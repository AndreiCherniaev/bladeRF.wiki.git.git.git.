This guide describes the process of building and installing the bladeRF host libraries and tool for a Mac OSX system, and quickly getting a device up and running using pre-built firmware and FPGA images.

== Installing Dependencies ==

Install XCode from Apple, as you will need a compiler. This is available in the App Store.

If you plan to use graphical tools (i.e., GNU Radio Companion), ensure you have X11 installed. See the [http://xquartz.macosforge.org/landing/ XQuartz project] for additional information and instructions.

Next, install a package management system, such as [http://www.macports.org/ MacPorts] (another option is [http://brew.sh/ Homebrew]).

The required dependencies are: libusb (with USB 3.0 support), pkgconfig, and cmake. The libtecla package is optional; it improves the bladeRF interactive console experience (adds history, vi-bindings, etc.). 

== MacPorts ==

With MacPorts, the bladeRF utilities can be installed with:

<pre>$ sudo port install bladeRF +tecla</pre>

Ensure that your shell configuration (e.g., .bashrc, .zshrc) contains the following items (adjusted accordingly):
<pre>
export DISPLAY=:0.0
export PATH=/opt/local/bin:/opt/local/sbin:$PATH
export MANPATH=/opt/local/share/man:$MANPATH
export PYTHONPATH=/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages:/opt/local/lib/python2.7/site-packages:${PYTHONPATH}
</pre>

There is no portfile for libtecla currently, so MacPorts users will have to 

== Homebrew==

If you're using Homebrew, install the dependencies via the following command. Note that you want to select libusb'''x'''.

<pre>$ brew install libusbx pkgconfig cmake libtecla</pre>

== Building bladeRF libraries and tools from source ==

Required dependencies include: libusb(x), CMake.  libtecla is optional, but highly recommended for bladeRF-cli.  MacPorts and Homebrew provide packages for all of these. 

=== Clone the bladeRF git repository ===

To obtain the latest source code for the first time, clone the Nuand git repository via:
<pre>
$ git clone https://github.com/Nuand/bladeRF.git
$ cd ./bladeRF
</pre>

In the future, you can update the repository via:
<pre>
$ git pull
</pre>

=== Configure the build ===

First enter the directory containing the host source. Then create and enter a directory to perform the build in. By working out of the a 'build' directory, it's easy to later clean up, by simply removing 'build/'.

<pre>
$ cd host/
$ mkdir build; cd build
</pre>


Next, configure the build. In the below example, we:
* Set up a Debug build
* Specify that files should be installed into /opt/local

<pre>
$ cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=/opt/local
</pre>

=== Perform the build and installation ===

Kick off the build and install to the location specified by ''CMAKE_INSTALL_PREFIX''.

<pre>
$ make
$ sudo make install
</pre>

=== Uninstalling later ===
Note that from this same directory, you can run the following to uninstall the files place on your system in the previous step. <pre>sudo make uninstall</pre> 

The ''install_manifest.txt'' file, created after running the install step successfully, lists all the files installed.  It is a good idea to back up this file if you plan on removing this build directory later.

== Checking basic device operation ==

=== Detecting the bladeRF ===
With the libraries and tools installed, we can now use the ''bladeRF-cli'' (command line interface) to probe for devices attached to the system.

First, take a look at the command-line options:
<pre>
$ bladeRF-cli --help
</pre>

* If you see the help text, you can skip ahead to the invocation with the ''-p'' option.

Note that the ''-p'' option may be used to probe for device. Plug in your device, and run the following command. You should see similar output.

<pre>
$ bladeRF-cli -p
    Backend:        libusb
    Serial:         f12ce1037830a1b27f3ceeba1f521413
    USB Bus:        253
    USB Address:    5
</pre>

If you do not see any device listed:
* Double-check that device is plugged in and that the jumpers on J70 are populated correctly
** LED D1 should be illuminated
* Try looking in Command-Space 'System Information' to see your USB devices.
* Verify that you have libusb 1.0.17 (check with 'port installed | grep libusb')
* Try both USB 2.0 and 3.0 ports

If you see additional issues with the device, ensure that you've [[Upgrading-bladeRF-firmware|upgraded to the latest firmware]].

=== Viewing additional device information ===

More information about the attached device can be viewed while running ''bladeRF-cli'' in interactive mode. Enter this mode and issue the '''help''' command to see a list of available command.  Use the '''info''' command to print information about the device, and '''version''' to view version information, most notably, the firmware:

<pre>
$ bladeRF-cli -i

bladeRF> help

... (Help text shown here ) ...

bladeRF> info

  Serial #:                 f12ce1037830a1b27f3ceeba1f521413                          
  VCTCXO DAC calibration:   0x9857
  FPGA size:                115 KLE
  FPGA loaded:              yes
  USB bus:                  253
  USB address:              5
  USB speed:                Hi-Speed
  Backend:                  libusb
  Instance:                 0

bladeRF> version
  bladeRF-cli version:        0.7.0-git-74980ad-dirty
  libbladeRF version:         0.9.0-git-74980ad-dirty

  Firmware version:           1.4.0
  FPGA version:               0.0.0

</pre>

Here we see the device's serial number, DAC calibration, FPGA information, and USB connection information.  Take note of the FPGA size, as this will help determine which FPGA file to load.

=== Loading the FPGA ===
Support for loading the FPGA from flash automatically is currently supported and undergoing further testing. See the <code>bladeRF-cli --help</code> text for information on how to write an FPGA image to flash for autoloading.

For simplicity, this guide shows how to load the FPGA without storing it into flash for autoloading. (As a result, you'll have to load the FPGA each time the device is reset or plugged in.)

FPGA images can be obtained from [[the Nuand website|http://www.nuand.com/fpga]] or from a [[nightly build of "bleeding edge" images|http://hoopycat.com/bladerf_builds/]].

To load an image from the command line.
<pre>
$ bladeRF-cli -l <path/to/fpga/file>
</pre>

Or to load an image while in interactive mode:
<pre>
bladeRF> load fpga <path/to/fpga/file>
</pre>

After the FPGA loads, you should see LEDs on the board begin blinking. At this point, you're ready to start using your device!

== Building/Fetching GNU Radio and gr-osmosdr ==

=== MacPorts ===

The following command may be used to install GNU Radio via [https://trac.macports.org/browser/trunk/dports/science/gnuradio/Portfile MacPorts], and any neccessary dependencies.

<pre>
$ sudo port install gnuradio +grc +swig +wxgui +qtgui +python27
</pre>

After the installation completes (it may take quite some time), you can verify the installation by running '''gnuradio-companion'''. Note: XQuartz will automatically start if it is not already started.

To get support for bladeRF sources in Gnuradio, you will need to install gr-osmosdr. Make sure you build bladeRF from source as above before running the port install command.

<pre>
$ sudo port install gr-osmosdr
</pre>

If you are having difficulty selecting a bladeRF source, you can check a list of supported device types in osmosdr with the following command.

<pre>
$ osmocom_fft 2>&1 | grep "source types"
built-in source types: file fcd rtl rtl_tcp uhd hackrf bladerf netsdr 
</pre>

If you have a good graphics card in your mac that supports opencl + opengl concurrently (currently it seems Intel's Iris Pro doesn't?), you can also install the fosphor sinks for gnuradio with.

<pre>
$ sudo port install gr-fosphor
</pre>

==== Building gr-osmosdr from source ====
'''Note''': This is not necessary if you've installed gr-osmosdr via the package manager; this is included here only for people that wish to work with and modify the source.

To avoid conflicts between the native python and the MacPorts-supplied python, it is necessary to point gr-osmosdr to the desired python items. Be sure to adjust the python-related items in your CMake invocation for any differences. See the [https://trac.macports.org/browser/trunk/dports/science/gr-osmosdr/Portfile gr-osmosdr portfile as a reference].

''h/t to Leonardo (@lvbernal) for identifying and pointing out the python caveats  [http://blog.lvbernal.com/2013_10_01_archive.html in his blog post].''


<pre>
$ git://git.osmocom.org/gr-osmosdr
$ cd gr-osmosdr
$ mkdir build
$ cd build
$ PKG_CONFIG_PATH=/opt/local/lib/pkgconfig cmake \
        -DPYTHON_EXECUTABLE=/opt/local/bin/python2.7 \
        -DPYTHON_INCLUDE_DIR=/opt/local/Library/Frameworks/Python.framework/Versions/2.7/Headers \
        -DPYTHON_LIBRARY=/opt/local/Library/Frameworks/Python.framework/Versions/2.7/Python \
        -DGR_PYTHON_DIR=/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages \
        -DCMAKE_INSTALL_PATH=/opt/local
        ../
</pre>

In the CMake output, you should see a '''nuand bladeRF''' entry in the '''gr-osmosdr enabled components''' list. Build and install via the following. 
<pre>
$ make
$ sudo make install
</pre>


Back up your install_manifest.txt for any future debugging or manual removal. You can run <code>sudo make uninstall</code> to remove the gr-osmosdr items.


=== Homebrew ===
The following is a bit vague, but it is assured to be workable.
As of Jan 2014 it seems that that gnuradio is still not yet part of the supported tree for Homebrew.
There are, however, several 3rd-party scripts.  One of them by user "titanous."
To use this, you need to run:
<pre>
  $ brew tap titanous/homebrew-gnuradio
</pre>
but it is advisable to see the README at https://github.com/titanous/homebrew-gnuradio since
there are several prerequisites and some options to consider.
Subsequent steps are akin to those under "Building gr-osmosdr from source" (above).



=== Simple Tests ===
See the [[Getting-Started:-Linux#wiki-Simple_test_applications_to_verify_device_operation|Getting Started: Linux]] guide for some quick tests to verify device operation with GNU Radio.